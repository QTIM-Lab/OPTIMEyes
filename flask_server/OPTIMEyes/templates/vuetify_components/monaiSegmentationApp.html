<!-- TEMPLATE -->
{% extends "vuetify_components/base.html" %}

<!-- TITLE -->
{% block title %}Monai Label{% endblock %}

<!-- CSS -->
{% block custom_css %}
<style>
  canvas {
    width: 100%;
    height: auto;
  }

  .parent {
    position: relative;
    top: 0;
    left: 0;
    background-color: rgb(255, 255, 255);
    width: 700px;
    height: 700px;
    border: 1px;
    border-style: dashed;    
  }
  #buttonWrapper {
      position: absolute;
      width: 20px;
      top: 5px;
      right: 15px;
      z-index: 4;
    }
  input[type="button"] {
    padding: 0px;
    width: 30px;
    height: 30px;
    margin: 0px;
    background-color: rgba(0, 255, 213, 0.264);
    border: 1px;
    border-style: solid;
  }
  .image {
    position: relative;
    top: 0;
    left: 0;
    display: block;
    max-width: 100%;
    max-height: 100%;
    width: 100%;
    height: 100%;
    /* Preserve aspect ratio while fitting */
    /* object-fit: contain; */ /* or object-fit: cover; depending on your preference */
  }
  .segmentation {
    position: absolute;
    top: 0px;
    left: 0px;
    max-width: 100%;
    max-height: 100%;
    width: 100%;
    height: 100%;
  }
  .coco {
    position: absolute;
    top: 0px;
    left: 0px;
    max-width: 100%;
    max-height: 100%;
    width: 100%;
    height: 100%;
  }
  .spinner {
    display: inline-block; /* Add this line */
    border: 4px solid rgba(255, 255, 255, 0.3);
    border-top: 4px solid #3498db;
    border-radius: 50%;
    width: 16px;
    height: 16px;
    animation: spin 1s linear infinite;
  }
  .spinner-inner {
    width: 8px;
    height: 8px;
    border: 4px solid transparent;
    border-top: 4px solid #3498db;
    border-radius: 50%;
    position: absolute;
    top: 0px;
    left: 0px;
    animation: spin 1s linear infinite;
  }
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  .check-mark {
    display: inline-block; /* Add this line */
    font-size: 16px;
    color: #4CAF50; /* Green color for the check mark */
  }
</style>
{% endblock %}

<!-- BODY -->
{% block content %}

<!-- Components -->
{% include 'vuetify_components/navbar.html' %}
{% include 'vuetify_components/timer.html' %}

<!-- Index Vue App -->
<div id="monai_segmentation_app">
    <v-app>
        <navbar-tag></navbar-tag>
      <v-main>
          <v-container>

              <v-btn v-if="images.length != 0" style="display: inline-block;">
                <v-tooltip left>
                  <template v-slot:activator="{ on }">
                    <v-icon v-on="on" style="font-style: normal; font-size: small;">Monai Label Task | On Image [[ task.value.current_idx + 1 ]] of [[ images.length ]]
                    </v-icon>
                  </template>
                  Image List Name: [[ list_name ]]
                </v-tooltip>
              </v-btn> 
              <timer-tag ref="timer" @update-time="updateTrackedTime"></timer-tag>
              <!-- Debug Time - comes from <timer-tag> -->
              <!-- <p>[[ total_sec ]]</p> -->
            
            <!-- Alert -->
            <v-alert
              title="Info"
              color="blue"
              elevation="4"
              type="info"
              v-if="alert_info != null"
            >
              [[ alert_info ]]
            </v-alert>
            <v-alert
              title="Error"
              color="red"
              elevation="4"
              type="error"
              v-if="alert_error != null"
            >
              [[ alert_error ]]
            </v-alert>

            <v-row no-gutters>
              <v-col ref="wtf"
                cols="12"
                lg="8"
              >

                <div ref="canvases_parent_div" class="parent">

                  <canvas
                    ref="image"
                    class="image"
                    :style="{ border: borderImage, 'z-index': image_z_index, opacity: image_opacity}"
                  ></canvas>
                  <div id="buttonWrapper">
                    <input type="button" id="plus" value="+">
                    <input type="button" id="minus" value="-">
                  </div>

                  <canvas
                    @mousedown="startBrushing"
                    @mousemove="brush"
                    @mouseup="stopBrushing"
                    ref="segmentation"
                    class="segmentation"
                    :style="{ border: borderSegmentation, opacity: 0.5, display: segmentation_image.display, 'z-index': segmentation_z_index}"
                  ></canvas>

                  <canvas
                    ref="coco"
                    class="coco"
                    :style="{ border: borderCoco, display: polygonDisplay, 'z-index': polygons_z_index}"
                  ></canvas>

                </div>
                
                <!-- Debugging with test canvas -->
                <canvas
                  ref="testcanvas"
                  style="border: 1px; border-style: solid; display: none;"
                  width="500"
                  height="435"
                ></canvas>
                <canvas
                  ref="patchCanvas"
                  style="border: 1px; border-style: solid; display: none;"
                  width="500"
                  height="435"
                ></canvas>


              </v-col>

              <v-col
              cols="12"
              lg="4"
              >

                <!-- Tools -->
                <!--https://codepen.io/zed_at_home/pen/LYpWyEM-->
                <v-form v-if="tool_set" action="/task_result" method="post" ref="form">
                  <v-row no-gutters>
                    <v-col
                    cols="12"
                    lg="12"
                    >
                      <!-- Segmentation Tools -->
                      <h4>Segmentation Tools:</h4>
                      <!-- Simple button example if needed for later -->
                      <!-- <v-btn @click="toggleTool('brush')"> 
                        <v-icon>[[ 'mdi-brush-outline' ]]</v-icon>
                        [[ BrushButtonText ]]
                      </v-btn> -->

                      <!-- Image Tools -->
                      <h4>Image Tools:</h4>
                      <v-btn :outlined="image_selected" @click="toggleTool('image')">
                        <v-tooltip left>
                          <template v-slot:activator="{ on }">
                            <v-icon v-on="on">[[ 'mdi-cursor-move' ]]</v-icon>
                          </template>
                          Move Image (Only if zoomed in)
                        </v-tooltip>
                      </v-btn>

                      <!-- Brush Options -->
                      <h5>Brush Options:</h5>
                      <v-btn :outlined="segmentation_selected" @click="toggleTool('brush')"> 
                        <v-tooltip left>
                          <template v-slot:activator="{ on }">
                            <v-icon v-on="on">[[ 'mdi-brush-outline' ]]</v-icon>
                          </template>
                        [[ BrushButtonText ]]
                        </v-tooltip>
                      </v-btn>
                      <v-btn @click="clearCanvas">
                        <v-icon>[[ 'mdi-eraser' ]]</v-icon>
                        Clear Brush
                      </v-btn>
                      <v-btn @click="hideCanvas">
                        <v-icon>[[ segmentation_image.display === '' ? 'mdi-eye-outline' : 'mdi-eye-off' ]]</v-icon>
                        [[ hideBrushButtonText ]]
                      </v-btn>
                      <!-- Brush size adjustment -->
                      <label>Size:</label>
                      <input type="range" v-model="brushSize" min="1" :max="brushSizeMax" />

                      <!-- Coco Polygon Options -->
                      <h4>Coco Polygon Options:</h4>
                      <v-btn :outlined="polygon_selected" @click="toggleTool('polygon')"> 
                        <v-tooltip left>
                          <template v-slot:activator="{ on }">
                            <v-icon v-on="on">[[ 'mdi-vector-polygon' ]]</v-icon>
                          </template>
                        [[ PolygonButtonText ]]
                        </v-tooltip>
                      </v-btn>
                      <!-- <v-btn @click="mergePolygonsToBrushCanvas">
                        <v-tooltip left>
                          <template v-slot:activator="{ on }">
                            <v-icon v-on="on">[[ 'mdi-stamper' ]]</v-icon>
                          </template>
                          (Stamp committed polygons onto brush canvas as brush pixels)
                        </v-tooltip>
                      </v-btn> -->
                      <v-btn @click="hidePolygon">
                        <v-icon>[[ polygonDisplay === '' ? 'mdi-eye-outline' : 'mdi-eye-off' ]]</v-icon>
                        [[ hidePolygonButtonText ]]
                      </v-btn>

                      <!-- Monai Label Buttons and Tools -->
                      <h4>Monai Label Tools:</h4>
                      <div style="display: none">
                      <!-- <div> -->
                        <v-btn @click="performInference">
                          <v-icon>[[ 'mdi-lightbulb-outline' ]]</v-icon>
                          Perform Inference
                          <div v-if="inferenceLoading" class="spinner">
                            <div class="spinner-inner"></div>
                          </div>
                          <div v-if="inferenceDoneTraining" class="check-mark">✔</div>
                        </v-btn>

                        <v-btn @click="saveLabel">
                          <v-icon>[[ 'mdi-content-save' ]]</v-icon>
                          Save Current Annotation
                          <div v-if="saveLoading" class="spinner">
                            <div class="spinner-inner"></div>
                          </div>
                          <div v-if="saveDoneTraining" class="check-mark">✔</div>
                        </v-btn>
                        
                        <v-btn @click="trainOnLabels">
                          <v-icon>[[ 'mdi-brain' ]]</v-icon>
                          Train on Saved Annotations
                          <div v-if="trainLoading" class="spinner">
                            <div class="spinner-inner"></div>
                          </div>
                          <div v-if="trainDoneTraining" class="check-mark">✔</div>
                        </v-btn>

                        <br>
                        
                        <v-btn @click="drawROI">
                          <v-tooltip left>
                            <template v-slot:activator="{ on }">
                              <v-icon v-on="on">[[ 'mdi-crop-square' ]]</v-icon> ROI
                            </template>
                            Region of Interest: [x_left, y_top, x_right, y_bottom]
                          </v-tooltip>
                        </v-btn>

                        <v-text-field label="ROI for Inference" v-model:value="roi"></v-text-field>                        

                      </div>

                    </v-col>
                  </v-row>  
                  <v-row no-gutters>
                    <v-col
                    cols="12"
                    lg="12"
                    >
                      <!-- Monai Label Buttons and Tools -->
                      <div
                        v-for="(checkbox_category, index_checkbox_category) in tool_set.checkbox_categories"
                        :key="checkbox_category['category_id']"
                      >
                        <p>[[ checkbox_category['category_id'] ]]</p>

                        <v-checkbox
                          v-for="(checkbox, indexCheckbox) in checkbox_category['checkboxes']"
                          :key="checkbox['checkbox_id']"
                          v-model="result.checkbox_categories[index_checkbox_category].checkboxes[indexCheckbox].checked"
                          :label="`${result.checkbox_categories[index_checkbox_category].checkboxes[indexCheckbox].checked.toString()}`"
                          color="red"
                          hide-details
                        ></v-checkbox>

                      </div>
                      <v-radio-group
                        v-for="(radio_button_category, index_radio_category) in tool_set.radio_button_categories"
                        :key="radio_button_category['category_id']"
                        v-model="result.radio_button_categories[index_radio_category].selected"
                      >
                        <p>[[ radio_button_category['category_id'] ]]</p>
                        <v-radio
                          v-for="(radio_button, index_radio_button) in radio_button_category['buttons']"
                          :key="radio_button['button_id']"
                          :label="`${result.radio_button_categories[index_radio_category].buttons[index_radio_button].button_id}`"
                          :value="`${result.radio_button_categories[index_radio_category].buttons[index_radio_button].button_id}`"                       
                          @click="toggleTool(result.radio_button_categories[index_radio_category].buttons[index_radio_button].button_id)"
                        ></v-radio>

                      </v-radio-group>
                    </v-col>
                    <v-col
                    cols="12"
                    lg="6"
                    >
                      <v-container>
                        <v-list dense>
                          <v-list-item-group>
                          <!-- If we need to model the selection later -->
                          <!-- <v-list-item-group v-model="selectedAnnotation"> -->
                            <v-list-item
                              v-for="(annotation, index) in coco_annotations"
                              :key="annotation.id"
                            >
                              <v-list-item-content>
                                <v-list-item-title>ID: [[ annotation.id ]]</v-list-item-title>
                                <v-list-item-subtitle>Area: [[ annotation.area ]]</v-list-item-subtitle>
                              </v-list-item-content>
                              <v-list-item-action>
                                <v-btn icon @click="deleteAnnotation(index)">
                                  <v-icon>mdi-delete</v-icon>
                                </v-btn>
                              </v-list-item-action>
                            </v-list-item>
                          </v-list-item-group>
                        </v-list>
                      </v-container>
                    </v-col>

                  </v-row>
                  <v-row no-gutters>
                    <div
                      v-for="(text_input_category, index_text_input_category) in tool_set.text_input_categories"
                      :key="text_input_category['category_id']"
                    >
                      <p>[[ text_input_category.category_id ]]</p>
                      <v-textarea
                        v-for="(text_input, index_text_input) in text_input_category['text_inputs']"
                        :key="text_input['text_input_id']"
                        v-model="result.text_input_categories[index_text_input_category].text_inputs[index_text_input].message"
                        :label="`${result.text_input_categories[index_text_input_category].text_inputs[index_text_input].text_input_id}`"
                      ></v-textarea>

                    </div>

                  </v-row>
                  <!--  -->

                  <v-btn
                    class="mr-4"
                    @click="submit"
                  >
                    Next Image
                  </v-btn>
                  <v-alert
                  title="Error"
                  color="red"
                  elevation="4"
                  type="error"
                  v-if="alert_error != null"
                >
                  [[ alert_error ]]
                </v-alert>
                  <!-- <v-btn @click="clear">
                    clear
                  </v-btn> -->
                  <v-btn @click="resetToPreviousResult">
                    Previous Image
                  </v-btn>

                </v-form>

              </v-col>

              </v-row>

            </v-container>
      </v-main>
    </v-app>
</div>

{% endblock %}

{% block js_scripts %}

<script>
var monai_segmentation_app =new Vue({
    el: '#monai_segmentation_app',
    vuetify: new Vuetify(),

    data: () => ({
      app: "monaiSegmentation",
      /* timer component variables */
      total_sec: 0,
      min: 0,
      sec: 0,
      /* ------------------------- */
      user: "{{ task.user }}",
      list_name: "{{ task.list_name }}",
      monaiLabelPort: 8000,
      images: [],
      // Image
      translatePos: {x:0,y:0},
      scale : 1.0, // Current zoom
      scaleMultiplier : 0.90, // increment for +/- operations
      image: {
        image_id: null, 
        base64: null
        // base64: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAH0CAIAAABEtEjdAAAC7UlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPwYdEkAAXvqzcMAAAAASUVORK5CYII="
      },
      imageCanvasMouseDownROIEventListerner: null,
      imageCanvasMouseUpROIEventListerner: null,
      imageCanvasMouseOutROIEventListerner: null,
      imageCanvasMouseMoveROIEventListerner: null,

      imageCanvasMouseDownInitCanvasEventListerner: null,
      imageCanvasMouseUpInitCanvasEventListerner: null,
      imageCanvasMouseOverInitCanvasEventListerner: null,
      imageCanvasMouseOutInitCanvasEventListerner: null,
      imageCanvasMouseMoveInitCanvasEventListerner: null,
      
      imageWidth: 0,
      imageHeight: 0,
      canvasWidth: 0, // These are the internal pixels; try to keep consistent with polygons and should match imageWidth
      canvasHeight: 0, // These are the internal pixels; try to keep consistent with polygons and should match imageHeight
      image_z_index: 0,
      image_opacity: 1,
      image_selected: false,
      aspectRatio: null, // important for dependent canvases
      borderImage: "0px green solid", /* for debugging */
      // Segmentation
      segmentation_image: {image_id: null, base64: null, display:""},
      borderSegmentation: "0px green solid", /* for debugging */
      segmentation_z_index: 2,
      segmentation_selected: true,
      //// Edit Segmentation
      isBrushing: false,
      brushSize: 10, // Default brush size
      
      // Coco polygons
      // coco_annotations: [{
      //   "segmentation": [[150.0,100.0, 150.0,250.0, 300.0,250.0, 400.0,175.0, 300.0,100.0]],
      //   "area": 22500,
      //   "iscrowd": 0,
      //   "image_id": 324158,
      //   "bbox":[0.0,0.0,350,400],
      //   "category_id": 1,
      //   "id": 11111111111111,
      // }],
      coco_annotations: [],
      // 01_23_2024
      vertices: [],
      currentSegmentation: [],
      // 01_23_2024
      borderCoco: "1px red solid", /* for debugging */
      hidePolygonButtonText: "Hide",
      polygonDisplay: "",
      polygons_z_index: 1,
      polygon_selected: false,
      // Hide Button
      hideBrushButtonText: "Hide",
      task: null,
      tool_set: null,
      result: null,
      alert_info: null,
      alert_error: null,
      BrushButtonText: "Brush (Selected)",
      PolygonButtonText: "Shape",
      // AI Tools
      //// ROI
      roi: JSON.stringify([0, 0, 0, 0]),
      roi_image: {base64: null},
      //// Spinners
      ////// Inference
      inferenceLoading: false,
      inferenceDoneTraining: false,
      ////// Save Image and Label to MonaiLabel
      saveLoading: false,
      saveDoneTraining: false,
      ////// Training
      trainLoading: false,
      trainIntervalId: null,
      trainDoneTraining: false,
      jobCompleted: false
    }),

    delimiters: ['[[',']]'],
    // watch: {
    //   // Watch the entire array of radio_button_categories for deep changes
    //   'result.radio_button_categories': {
    //     handler: function (newValues, oldValues) {
    //       for (let i = 0; i < newValues.length; i++) {
    //         if (newValues[i].selected !== oldValues[i].selected) {
    //           // Do something when a selection is made
    //           this.onSelectionChange(i, newValues[i].selected);
    //         }
    //       }
    //     },
    //     deep: true, // This is necessary to watch inside the array for object changes
    //   },
    // },
    async mounted() {
        configuration = await this.getConfiguration()
        this.DNS = configuration.DNS;
        this.SSL = configuration.SSL;
        this.IMAGES_DB = configuration.IMAGES_DB;
        this.DB_PORT = configuration.DB_PORT;
        this.HTTP_PORT = configuration.HTTP_PORT;
        this.ADMIN_PARTY = configuration.ADMIN_PARTY;
        this.USER_INFO = configuration.USER_INFO;
        await this.getTask(this.app, this.user, this.list_name);
        if (this.task.value.completed){
          this.alert_info = "This task is completed"
          setTimeout(()=>{this.alert_info = null}, 2000)
          setTimeout(()=>{window.location.replace(this.URLS.taskList);}, 2000)
        }else{
          await this.getImageList();
          this.getTools(this.app, this.task.value.tool_set)
          // Get image
          this.image.image_id = this.images[this.task.value.current_idx]
          this.image['base64'] = await this.getBase64DataOfImageFromCouch(this.image.image_id)
          
          await this.displayCanvasImage(current_image=this.task.value.current_idx);
          this.displayBrushImage(current_image=this.task.value.current_idx);
          this.drawAnnotations(); //
          this.initCoco();
          this.initCanvasZoomTools();
          this.performInference();

          this.resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
              const {width} = entry.contentRect;
              const newHeight = width / this.aspectRatio; // Calculate the new height based on the aspect ratio
              // This is the trick right here.
              // Aspect ratio is the secret weapon
              current_working_width = this.$refs['canvases_parent_div'].parentElement.offsetWidth
              current_working_height = current_working_width/MS.aspectRatio
              this.$refs['canvases_parent_div'].style.width = `${current_working_width}px`
              this.$refs['canvases_parent_div'].style.height = `${current_working_width/(this.aspectRatio === null ? 1 : this.aspectRatio)}px`
              // Dumped here just to calc MS.translatePos.x and MS.translatePos.y
              const imageCanvas = MS.$refs['image'];
              current_working_height = current_working_width/MS.aspectRatio
              max_x_pixels_you_can_shift_image = MS.imageWidth * (1 - (1 / MS.scale)) * ( current_working_width / imageCanvas.width )
              max_y_pixels_you_can_shift_image = MS.imageHeight * (1 - (1 / MS.scale)) * ( current_working_height / imageCanvas.height )
              MS.translatePos.x = Math.max(Math.min(MS.translatePos.x, max_x_pixels_you_can_shift_image), 0)
              MS.translatePos.y = Math.max(Math.min(MS.translatePos.y, max_y_pixels_you_can_shift_image), 0)
            }
          });
          this.resizeObserver.observe(this.$refs['canvases_parent_div']); // Observe the size of the canvas parent div         

        }
    },

    computed: {
      // General
      URLS() {
          return {
              configuration: "/configuration",
              monaiSegmentationApp: `/monaiSegmentationApp/${this.user}/${this.list_name}`,
              getTask: `/get_task/${this.app}/${this.user}/${this.list_name}`,
              taskList: `/tasksList`,
              getToolSet: `/get_toolset`,
              getImageList: `/get_image_monai_segmentation_lists`,
              taskResult: `/task_result`,
              resetToPreviousResult: `/reset_to_previous_result`,
              // MonaiLabel URLS
              activeLearning: `http://${this.DNS}:${this.monaiLabelPort}/activelearning/last`,
              // performInference: `http://${this.DNS}:${this.monaiLabelPort}/infer/SegformerBundle`,
              performInference: `http://${this.DNS}:${this.monaiLabelPort}/infer/MedSamBundle`,
              uploadImage: `http://${this.DNS}:${this.monaiLabelPort}/datastore/image`,
              saveLabel: `http://${this.DNS}:${this.monaiLabelPort}/datastore/label`,
              // trainOnLabels: `http://${this.DNS}:${this.monaiLabelPort}/train/SegformerBundle`,
              trainOnLabels: `http://${this.DNS}:${this.monaiLabelPort}/train/MedSamBundle`,
              trainStatus: `http://${this.DNS}:${this.monaiLabelPort}/train/?all=false&check_if_running=false`
          }
      },
      brushSizeMax(){
        current_working_width = this.$refs['canvases_parent_div'].parentElement.offsetWidth
        let tmp_scale = this.imageWidth / current_working_width
        let brushSizeMax = 100*tmp_scale
        // Set brush size
        this.brushSize = brushSizeMax / 4
        return brushSizeMax
      }
    },

    methods: {
      updateTrackedTime(total_sec, min, sec) {
        // From child <timer-tag>
        this.total_sec = total_sec
        this.min = min
        this.sec = sec;
      },
      initCanvasZoomTools(){
        MS = this;
        var canvas = this.$refs.image;
        var startDragOffset = {};
        var mouseDown = false;

        // add button event listeners
        document.getElementById("plus").addEventListener("click", async function() {
          MS.scale /= MS.scaleMultiplier;
          await MS.displayCanvasImage(MS.current_image, translatePos=MS.translatePos, scale=MS.scale);
          MS.drawAnnotations(recursion_base_case=0, translatePos=MS.translatePos, scale=MS.scale);
          MS.displayBrushImage(current_image=MS.task.value.current_idx, recursion_base_case=0, translatePos=MS.translatePos, scale=MS.scale);
          MS.drawVertices();
        }, false);

        document.getElementById("minus").addEventListener("click", async function() {
          if(MS.scale * MS.scaleMultiplier >= 1.0){
            MS.scale *= MS.scaleMultiplier;          
            await MS.displayCanvasImage(MS.current_image, translatePos=MS.translatePos, scale=MS.scale);
            MS.drawAnnotations(recursion_base_case=0, translatePos=MS.translatePos, scale=MS.scale);
            MS.displayBrushImage(current_image=MS.task.value.current_idx, recursion_base_case=0, translatePos=MS.translatePos, scale=MS.scale);
            MS.drawVertices();
          }
        }, false);

        function onMouseUp(evt) {
          console.log("initCanvasZoomTools onMouseUp")
          mouseDown = false;
        }
        
        function onMouseOver(evt) {
          console.log("initCanvasZoomTools onMouseOver")
          mouseDown = false;
        }
        
        function onMouseOut(evt) {
          console.log("initCanvasZoomTools onMouseOut")
          mouseDown = false;
        }
        
        // add event listeners to handle screen drag
        function onMouseDown(evt) {
          console.log("initCanvasZoomTools onMouseDown")
          // canvas.removeEventListener("mousedown", MS.imageCanvasMouseDownROIEventListerner)
          mouseDown = true;
          // startDragOffset.x = evt.clientX + canvas.getBoundingClientRect().left + MS.translatePos.x; // literal pixels on screen\browser
          // startDragOffset.y = evt.clientY + canvas.getBoundingClientRect().top + MS.translatePos.y; // literal pixels on screen\browser
          startDragOffset.x = evt.clientX + MS.translatePos.x; // forward (mouse slides image around)
          startDragOffset.y = evt.clientY + MS.translatePos.y; // forward (mouse slides image around)
          // startDragOffset.x = evt.clientX - MS.translatePos.x; // reverse (mouse is moving across image)
          // startDragOffset.y = evt.clientY - MS.translatePos.y; // reverse (mouse is moving across image)
        }
        this.imageCanvasMouseDownInitCanvasEventListerner = onMouseDown
        this.imageCanvasMouseUpInitCanvasEventListerner = onMouseUp
        this.imageCanvasMouseOverInitCanvasEventListerner = onMouseOver
        this.imageCanvasMouseOutInitCanvasEventListerner = onMouseOut
        this.imageCanvasMouseMoveInitCanvasEventListerner = onMouseMove
        
        // done in this..toggleTool()
        // canvas.addEventListener("mousedown", onMouseDown);
        // canvas.addEventListener("mouseup", onMouseUp);
        // canvas.addEventListener("mouseover", onMouseOver);
        // canvas.addEventListener("mouseout", onMouseOut);
        // canvas.addEventListener("mousemove", onMouseMove);
        
        function onMouseMove(evt) {
          console.log("initCanvasZoomTools onMouseMove")
          if (mouseDown) {
            const imageCanvas = MS.$refs['image'];
            current_working_width = MS.$refs['canvases_parent_div'].parentElement.offsetWidth
            current_working_height = current_working_width/MS.aspectRatio
            max_x_pixels_you_can_shift_image = MS.imageWidth * (1 - (1 / MS.scale)) * ( current_working_width / imageCanvas.width )
            max_y_pixels_you_can_shift_image = MS.imageHeight * (1 - (1 / MS.scale)) * ( current_working_height / imageCanvas.height )
            
            MS.translatePos.x = Math.max(0, Math.min(startDragOffset.x - evt.clientX, max_x_pixels_you_can_shift_image)) // forward (mouse slides image around)
            MS.translatePos.y = Math.max(0, Math.min(startDragOffset.y - evt.clientY, max_y_pixels_you_can_shift_image)) // forward (mouse slides image around)
            // MS.translatePos.x = Math.max(0, Math.min(evt.clientX - startDragOffset.x, max_x_pixels_you_can_shift_image)) // reverse (mouse is moving across image)
            // MS.translatePos.y = Math.max(0, Math.min(evt.clientY - startDragOffset.y, max_y_pixels_you_can_shift_image)) // reverse (mouse is moving across image)
            
            // add scale soon
            if(MS.scale > 1.0){
              MS.displayCanvasImage(MS.current_image, translatePos=MS.translatePos, scale=MS.scale);
              MS.displayBrushImage(current_image=MS.task.value.current_idx, translatePos=MS.translatePos, scale=MS.scale);
              MS.drawAnnotations(recursion_base_case=0, translatePos=MS.translatePos, scale=MS.scale);
              MS.drawVertices()
            }
          }
        }         
        
      },
      mergePolygonsToBrushCanvas(){
        // Get the canvas elements
        var cocoCanvas = this.$refs['coco'];
        var segmentationCanvas = this.$refs['segmentation'];
        var testCanvas = this.$refs['testcanvas'];
        var patchCanvas = this.$refs['patchCanvas'];

        // Get the 2D contexts of the canvases
        var cocoContext = cocoCanvas.getContext('2d');
        var segmentationContext = segmentationCanvas.getContext('2d');
        var testContext = testCanvas.getContext('2d');
        var patchContext = patchCanvas.getContext('2d');
        segmentationContext.globalCompositeOperation = "source-over"; // unsure about this...01_09_2024
        
        // Here, you need to access the polygons data from the 'coco' canvas.
        // This will depend on how you're storing the drawn polygons.
        // Assuming you have an array of polygon points:
        var coco_annotations = this.coco_annotations; // Your polygons data structure
        // Clear the segmentation canvas if needed
        // segmentationContext.clearRect(0, 0, segmentationCanvas.width, segmentationCanvas.height);
        current_working_width = this.$refs['canvases_parent_div'].parentElement.offsetWidth
        current_working_height = current_working_width/this.aspectRatio
        // Iterate over the polygons and draw them on the segmentation canvas 
        coco_annotations.forEach(segmentation => {
          const points = segmentation.segmentation;
          if (points.length > 0) {
            // Draw on testCanvas
            testContext.beginPath();
            testContext.fillStyle = `#ff0000`;
            testContext.moveTo(points[0], points[1]);
            for (let i = 2; i < points.length; i += 2) {
              testContext.lineTo(points[i], points[i + 1]);
            }
            testContext.closePath();
            testContext.fill(); // Or use .stroke() if you just want the outline
          }
          this.segmentation_image.base64 = testCanvas.toDataURL('image/png')
          // Draw back on segmentation canvas from test canvas
          sX = MS.translatePos.x * (segmentationCanvas.width / current_working_width)
          sY = MS.translatePos.y * (segmentationCanvas.height / current_working_height)
          sW = MS.imageWidth / (scale)
          sH = MS.imageHeight / (scale)
          dX = 0
          dY = 0
          dW = segmentationCanvas.width
          dH = segmentationCanvas.height
          segmentationContext.drawImage(testCanvas, sX, sY, sW, sH, dX, dY, dW, dH);
          // Draw back on patch canvas from test canvas
          patchContext.drawImage(testCanvas, sX, sY, sW, sH, dX, dY, dW, dH);
        });

      },
      deleteAnnotation(index) {
        // Confirm with the user before deleting
        if (confirm(`Are you sure you want to delete annotation with ID ${this.coco_annotations[index].id}?`)) {
          // Remove the annotation from the array
          this.coco_annotations.splice(index, 1);
          this.drawAnnotations(recursion_base_case=0, translatePos=MS.translatePos, scale=MS.scale);
        }
      },
      initCoco(){
        MS = this;
        const canvas = this.$refs['coco'];
        const ctx = canvas.getContext('2d');
        // Load the annotations for the image
        // let currentSegmentation = []; // delete when sure it works
        // Create an array to store draggable points (vertices)
        // const vertices = []; // delete when sure it works

        // Flag to track whether the user is currently drawing a polygon
        let isDrawing = false;
        
        const x_scaler = MS.imageWidth / parseFloat( MS.$refs.canvases_parent_div.style.width.replace("px","") ) // Adjust x point clicked
        const y_scaler = MS.imageHeight / parseFloat( MS.$refs.canvases_parent_div.style.height.replace("px","") ) // Adjust y point clicked

        function onMouseMoveFootPrint(event) {
          const newX = event.clientX - canvas.getBoundingClientRect().left;
          const newY = event.clientY - canvas.getBoundingClientRect().top;
          translatedX = newX*x_scaler/MS.scale + MS.translatePos.x*x_scaler;
          translatedY = newY*y_scaler/MS.scale + MS.translatePos.y*y_scaler;

          // MS.drawVertices(translatePos=MS.translatePos, scale=MS.scale);
          const newVertex = { translatedX, translatedY };
          MS.vertices.push(newVertex);
          MS.drawVertices(translatePos=MS.translatePos, scale=MS.scale);
        }
        function undo_vertice_placement() {
              // Check if there are vertices to delete
              if (MS.vertices.length > 0) {
                // Remove the last vertex
                MS.vertices.pop();
                // Redraw the annotations with the updated vertices
                MS.drawVertices(translatePos=MS.translatePos, scale=MS.scale);
              }
        }    
        document.addEventListener('contextmenu', event => {
          event.preventDefault();
        });
        document.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            canvas.removeEventListener('mousemove', onMouseMoveFootPrint);
            // Enter key saves the current polygon (if one is being drawn)
            if (isDrawing && MS.vertices.length > 0) {
              isDrawing = false;
              points = MS.currentSegmentation.segmentation
              for (let i = 0; i < points.length; i += 2) {
                // points and data at this point should be real relative to full size image
                MS.currentSegmentation.segmentation[i] = points[i] //- MS.translatePos.x
                MS.currentSegmentation.segmentation[i+1] = points[i+1] //- MS.translatePos.y
              }
              this.coco_annotations.push(MS.currentSegmentation); // Store the current polygon
              MS.vertices.length = 0; // Clear the vertices
              this.drawAnnotations(recursion_base_case=0, translatePos=MS.translatePos, scale=MS.scale);
            }
            event.preventDefault(); // Prevent the default behavior of the Enter key
            // 05_13_2024
            this.mergePolygonsToBrushCanvas()
          } else if (event.key === "Backspace" || event.key === "Delete"){
            undo_vertice_placement()
          }

        });
        canvas.addEventListener('dblclick', (event) => {
          canvas.addEventListener('mousemove', onMouseMoveFootPrint);
        })
        canvas.addEventListener('mousedown', (event) => {
          // Delete if nothing bad happens for a while 05/16/2024
          // const x_scaler = MS.imageWidth / parseFloat( MS.$refs.canvases_parent_div.style.width.replace("px","") ) // Adjust x point clicked
          // const y_scaler = MS.imageHeight / parseFloat( MS.$refs.canvases_parent_div.style.height.replace("px","") ) // Adjust y point clicked
          const x = event.clientX - canvas.getBoundingClientRect().left; // literal pixels on screen\browser
          const y = event.clientY - canvas.getBoundingClientRect().top; // literal pixels on screen\browser
          // Check if a vertex was clicked (within a certain radius)
          v = 0
          const clickedVertex = MS.vertices.find((vertex) => {
            v+=1
            where_on_image_clicked_x = x*x_scaler/MS.scale + MS.translatePos.x*x_scaler
            where_on_image_clicked_y = y*y_scaler/MS.scale + MS.translatePos.y*y_scaler
            const distance = Math.sqrt((vertex.translatedX - where_on_image_clicked_x) ** 2 + (vertex.translatedY - where_on_image_clicked_y) ** 2);
            // threshold = x_scaler*y_scaler // before
            threshold = 2.5 * MS.imageWidth / current_working_width
            return distance < threshold; // Adjust the radius as needed for your click detection
          });

          function onMouseMoveClickedVertex(event) {
            const newX = event.clientX - canvas.getBoundingClientRect().left;
            const newY = event.clientY - canvas.getBoundingClientRect().top;
            // clickedVertex.x = newX; // original
            clickedVertex.translatedX = newX*x_scaler/MS.scale + MS.translatePos.x*x_scaler;
            // clickedVertex.y = newY; // original
            clickedVertex.translatedY = newY*y_scaler/MS.scale + MS.translatePos.y*y_scaler;
            MS.drawVertices(translatePos=MS.translatePos, scale=MS.scale);
          }
          function onMouseUp() {
            canvas.removeEventListener('mousemove', onMouseMoveClickedVertex);
            canvas.removeEventListener('mouseup', onMouseUp);
            canvas.removeEventListener('mousemove', onMouseMoveFootPrint);
          }
          if (clickedVertex) {
            // Clicked on an existing vertex, make it draggable
            canvas.addEventListener('mousemove', onMouseMoveClickedVertex);
            canvas.addEventListener('mouseup', onMouseUp);
          } else if (event.button === 2) {
            undo_vertice_placement()
          } else {
            newX = x*x_scaler/MS.scale + MS.translatePos.x*x_scaler
            newY = y*y_scaler/MS.scale + MS.translatePos.y*y_scaler
            if (!isDrawing) {
              // Clicked outside existing vertices, add a new point
              isDrawing = true;
              translatedX = newX
              translatedY = newY
              const newVertex = { translatedX, translatedY };
              MS.vertices.push(newVertex);
            } else {
              // Continue adding vertices to the current polygon
              translatedX = newX
              translatedY = newY
              const newVertex = { translatedX, translatedY };
              MS.vertices.push(newVertex);
            }
            // Redraw the entire canvas with updated points
            MS.drawVertices(translatePos=MS.translatePos, scale=MS.scale);
          }
        });

        // Add a keyboard event listener to listen for Ctrl+Z keypress
        document.addEventListener('keydown', (event) => {
          if (event.ctrlKey && event.key === 'z') {
            undo_vertice_placement()
          }
        });

        // function calculateArea(segmentation) {
        //   // Implement a function to calculate the area of a segmentation.
        //   // You can use a formula or algorithm to calculate the area based on the segmentation points.
        //   // This depends on your specific requirements.
        //   return 100
        // }

        // function calculateBoundingBox(segmentation) {
        //   // Implement a function to calculate the bounding box of a segmentation.
        //   // You can find the minimum and maximum x and y coordinates in the segmentation points.
        //   // This depends on your specific requirements.
        //   return [0.0,0.0, 0.0,0.0]
        // }
        
        // function generateUniqueId() {
        //   // Implement a function to generate a unique ID for each segmentation.
        //   // You can use a timestamp, a random number generator, or any other method to ensure uniqueness.
        //   // This depends on your specific requirements.
        //   return Date.now()
        // }

        // function drawVertices(translatePos={x:0,y:0}, scale=1.0) {
        //   ctx.clearRect(0, 0, canvas.width, canvas.height); // I'm concerned here
        //   // fingers crossed
        //   const imageCanvas = MS.$refs['image'];
        //   current_working_width = MS.$refs['canvases_parent_div'].parentElement.offsetWidth
        //   current_working_height = current_working_width/MS.aspectRatio
        //   max_x_pixels_you_can_shift_image = MS.imageWidth * (1 - (1 / MS.scale)) * ( current_working_width / imageCanvas.width )
        //   max_y_pixels_you_can_shift_image = MS.imageHeight * (1 - (1 / MS.scale)) * ( current_working_height / imageCanvas.height )
        //   MS.translatePos.x = Math.max(Math.min(MS.translatePos.x, max_x_pixels_you_can_shift_image), 0)
        //   MS.translatePos.y = Math.max(Math.min(MS.translatePos.y, max_y_pixels_you_can_shift_image), 0)
        //   MS.drawAnnotations(recursion_base_case=0, translatePos=MS.translatePos, scale=MS.scale)
          
        //   // Draw existing vertices
        //   ctx.save()
        //   ctx.scale(scale, scale)
        //   ctx.translate( -translatePos.x * (canvas.width/current_working_width), -translatePos.y * (canvas.height/current_working_height) )
        //   ctx.fillStyle = 'blue'; // Set the vertex color
        //   vertices.forEach((vertex) => {
        //     ctx.beginPath();
        //     // Retrieve to scale vertexes
        //     current_working_width = MS.$refs['canvases_parent_div'].parentElement.offsetWidth
        //     let arc_x = vertex.translatedX
        //     let arc_y = vertex.translatedY
        //     let arc_radius = 2 * MS.imageWidth / current_working_width // arbitrary sizing based on canvas div and image width then again scaled by 2, arbitrarily
        //     let arc_startAngle = 0
        //     let arc_endAngle = 2 * Math.PI
        //     ctx.arc(arc_x, arc_y, arc_radius, arc_startAngle, arc_endAngle);
        //     ctx.fill();
        //   });

        //   // Draw the polygon based on the vertices
        //   ctx.fillStyle = 'rgba(0, 255, 0, 0.10)'; // Transparent (Green)
        //   ctx.strokeStyle = 'rgba(0, 255, 0, 1)'; // Set the line color (Green)
        //   ctx.lineWidth = MS.imageWidth / current_working_width; // Set the line width
        //   ctx.beginPath();
        //   if (vertices.length > 0){
        //     ctx.moveTo(vertices[0].translatedX, vertices[0].translatedY);
        //     vertices.forEach((vertex) => {
        //       ctx.lineTo(vertex.translatedX, vertex.translatedY);
        //     });
        //     ctx.closePath();
        //     ctx.fill();
        //     ctx.stroke();
        //   }
        //   ctx.stroke();
        //   ctx.restore();
        //   // Update cocoAnnotations based on vertices
        //   const segmentation = vertices.map((vertex) => [vertex.translatedX, vertex.translatedY]);
        //   const flattenedSegmentation = vertices.reduce((acc, vertex) => {
        //     acc.push(vertex.translatedX, vertex.translatedY);
        //     return acc;
        //   }, []);
        //   const newSegmentation = {
        //     segmentation: flattenedSegmentation,
        //     area: calculateArea(segmentation),
        //     iscrowd: 0,
        //     image_id: MS.image.image_id, // Set the image ID as needed
        //     bbox: calculateBoundingBox(segmentation),
        //     category_id: 1, // Set the category ID as needed
        //     id: generateUniqueId(), // Generate a unique ID for the segmentation
        //   };
        //   currentSegmentation = newSegmentation;
        // }
      },
      calculateArea(segmentation) {
          // Implement a function to calculate the area of a segmentation.
          // You can use a formula or algorithm to calculate the area based on the segmentation points.
          // This depends on your specific requirements.
          return 100
      },
      calculateBoundingBox(segmentation) {
        // Implement a function to calculate the bounding box of a segmentation.
        // You can find the minimum and maximum x and y coordinates in the segmentation points.
        // This depends on your specific requirements.
        return [0.0,0.0, 0.0,0.0]
      },
      generateUniqueId() {
        // Implement a function to generate a unique ID for each segmentation.
        // You can use a timestamp, a random number generator, or any other method to ensure uniqueness.
        // This depends on your specific requirements.
        return Date.now()
      },
      drawVertices(translatePos={x:0,y:0}, scale=1.0) {
        const canvas = this.$refs['coco'];
        const ctx = canvas.getContext('2d');

        ctx.clearRect(0, 0, canvas.width, canvas.height); // I'm concerned here
        // fingers crossed
        const imageCanvas = MS.$refs['image'];
        current_working_width = MS.$refs['canvases_parent_div'].parentElement.offsetWidth
        current_working_height = current_working_width/MS.aspectRatio
        max_x_pixels_you_can_shift_image = MS.imageWidth * (1 - (1 / MS.scale)) * ( current_working_width / imageCanvas.width )
        max_y_pixels_you_can_shift_image = MS.imageHeight * (1 - (1 / MS.scale)) * ( current_working_height / imageCanvas.height )
        MS.translatePos.x = Math.max(Math.min(MS.translatePos.x, max_x_pixels_you_can_shift_image), 0)
        MS.translatePos.y = Math.max(Math.min(MS.translatePos.y, max_y_pixels_you_can_shift_image), 0)
        MS.drawAnnotations(recursion_base_case=0, translatePos=MS.translatePos, scale=MS.scale)
        
        // Draw existing vertices
        ctx.save()
        ctx.scale(scale, scale)
        ctx.translate( -translatePos.x * (canvas.width/current_working_width), -translatePos.y * (canvas.height/current_working_height) )
        ctx.fillStyle = 'blue'; // Set the vertex color
        MS.vertices.forEach((vertex) => {
          ctx.beginPath();
          // Retrieve to scale vertexes
          current_working_width = MS.$refs['canvases_parent_div'].parentElement.offsetWidth
          let arc_x = vertex.translatedX
          let arc_y = vertex.translatedY
          let arc_radius = 2 * MS.imageWidth / current_working_width // arbitrary sizing based on canvas div and image width then again scaled by 2, arbitrarily
          let arc_startAngle = 0
          let arc_endAngle = 2 * Math.PI
          ctx.arc(arc_x, arc_y, arc_radius, arc_startAngle, arc_endAngle);
          ctx.fill();
        });
        // Draw the polygon based on the vertices
        ctx.fillStyle = 'rgba(0, 255, 0, 0.10)'; // Transparent (Green)
        ctx.strokeStyle = 'rgba(0, 255, 0, 1)'; // Set the line color (Green)
        ctx.lineWidth = MS.imageWidth / current_working_width; // Set the line width
        ctx.beginPath();
        if (MS.vertices.length > 0){
          ctx.moveTo(MS.vertices[0].translatedX, MS.vertices[0].translatedY);
          MS.vertices.forEach((vertex) => {
            ctx.lineTo(vertex.translatedX, vertex.translatedY);
          });
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
        }
        ctx.stroke();
        ctx.restore();
        // Update cocoAnnotations based on vertices
        const segmentation = MS.vertices.map((vertex) => [vertex.translatedX, vertex.translatedY]);
        const flattenedSegmentation = MS.vertices.reduce((acc, vertex) => {
          acc.push(vertex.translatedX, vertex.translatedY);
          return acc;
        }, []);
        const newSegmentation = {
          segmentation: flattenedSegmentation,
          area: MS.calculateArea(segmentation),
          iscrowd: 0,
          image_id: MS.image.image_id, // Set the image ID as needed
          bbox: MS.calculateBoundingBox(segmentation),
          category_id: 1, // Set the category ID as needed
          id: MS.generateUniqueId(), // Generate a unique ID for the segmentation
        };
        MS.currentSegmentation = newSegmentation;
      },
      drawAnnotations(recursion_base_case=0, translatePos={x:0,y:0}, scale=1.0) {
        const coco = this.$refs['coco'];
        MS = this;
        coco.width = MS.imageWidth // clears canvas
        coco.height = MS.imageHeight // clears canvas
        const coco_ctx = coco.getContext('2d');
        coco_ctx.save() // to preserve state for drawing verticies (live annotation object being created)
        coco_ctx.scale(scale, scale)
        current_working_width = this.$refs['canvases_parent_div'].parentElement.offsetWidth
        current_working_height = current_working_width/this.aspectRatio
        
        coco_ctx.translate( -translatePos.x * (coco.width/current_working_width), -translatePos.y * (coco.height/current_working_height) )
        // Load the annotations for the image
        var cocoAnnotations = this.coco_annotations;
        // Draw existing segmentations
        if (cocoAnnotations.length > 0){
          cocoAnnotations.forEach((segmentation) => {
            const points = segmentation.segmentation;
            if (points.length > 0) {
              coco_ctx.fillStyle = 'rgba(255, 0, 0, 0.10)';
              coco_ctx.strokeStyle = 'rgba(255, 0, 0, 1)'; // Set the line color
              coco_ctx.lineWidth = MS.imageWidth / current_working_width; // Set the line width
              coco_ctx.beginPath();
              coco_ctx.moveTo(points[0], points[1]);
              for (let i = 2; i < points.length; i += 2) {
                coco_ctx.lineTo(points[i], points[i + 1]);
              }
              coco_ctx.closePath();
              coco_ctx.fill();
              coco_ctx.stroke();
            }
          });
        }
        coco_ctx.restore()
      },
      drawROI(translatePos={x:0,y:0}, scale=1.0) {
        const imageCanvas = MS.$refs['image'];
        // Remove Move Tools reactivity
        // imageCanvas.removeEventListener("mousemove", this.imageCanvasMouseMoveEventListerner)
        var x_scaler = MS.imageWidth / parseFloat( MS.$refs.canvases_parent_div.style.width.replace("px","") ) // Adjust x point clicked
        var y_scaler = MS.imageHeight / parseFloat( MS.$refs.canvases_parent_div.style.height.replace("px","") ) // Adjust y point clicked

        // add event listeners to handle roi definition
        var startDragOffset = {};
        var drag = {};
        var mouseDown = false;

        function onMouseDown(evt) {
          console.log("ROI onMouseDown")
          
          // imageCanvas.addEventListener("mousemove", onMouseMove);
          // imageCanvas.addEventListener("mouseup", onMouseUp);
          
          // setTimeout(()=>{MS.displayCanvasImage()}, 2000)
          MS.displayCanvasImage(MS.current_image, translatePos=MS.translatePos, scale=MS.scale);
          mouseDown = true;
          x_scaler = MS.imageWidth / parseFloat( MS.$refs.canvases_parent_div.style.width.replace("px","") ) // Adjust x point clicked
          y_scaler = MS.imageHeight / parseFloat( MS.$refs.canvases_parent_div.style.height.replace("px","") ) // Adjust y point clicked
          const x = evt.clientX - imageCanvas.getBoundingClientRect().left; // literal pixels on screen\browser
          const y = evt.clientY - imageCanvas.getBoundingClientRect().top; // literal pixels on screen\browser
          // const x = evt.offsetX; // literal pixels on screen\browser
          // const y = evt.offsetY; // literal pixels on screen\browser
          // console.log(MS.scale)
          // console.log(`x ${x} | x ${y}`)
          // console.log(`evt.clientX ${evt.clientX} | evt.clientY ${evt.clientY}`)
          // console.log(`x_scaler ${x_scaler} | y_scaler ${y_scaler}`)
          where_on_image_clicked_x = x*x_scaler/MS.scale + MS.translatePos.x*x_scaler
          where_on_image_clicked_y = y*y_scaler/MS.scale + MS.translatePos.y*y_scaler

          startDragOffset.x = where_on_image_clicked_x; // forward (mouse slides image around)
          startDragOffset.y = where_on_image_clicked_y; // forward (mouse slides image around)
          // startDragOffset.x = evt.clientX - MS.translatePos.x; // reverse (mouse is moving across image)
          // startDragOffset.y = evt.clientY - MS.translatePos.y; // reverse (mouse is moving across image)
          console.log(`roi startDragOffset.x: ${startDragOffset.x}`)
          console.log(`roi startDragOffset.y: ${startDragOffset.y}`)
          
        }
        
        function onMouseUp(evt) {
          console.log("ROI onMouseUp")
          mouseDown = false;
          startDragOffset.x = 0
          startDragOffset.y = 0
          displayROI(imageCanvas);
          // setTimeout(()=>{MS.displayCanvasImage()}, 2000)
          // imageCanvas.removeEventListener('mousemove', onMouseMove);
          // imageCanvas.removeEventListener('mouseup', onMouseUp);          
          // imageCanvas.removeEventListener('mousedown', onMouseDown);
          // imageCanvas.removeEventListener('mouseout', onMouseOut);
        }
        
        function onMouseOut(evt) {
          console.log("ROI onMouseOut")
          
          mouseDown = false;
          startDragOffset.x = 0
          startDragOffset.y = 0
          // imageCanvas.removeEventListener('mousemove', onMouseMove);
          // imageCanvas.removeEventListener('mouseup', onMouseUp);
          // imageCanvas.removeEventListener('mousedown', onMouseDown);
          // imageCanvas.removeEventListener('mouseout', onMouseOut);
        }
        
        function onMouseMove(evt) {
          console.log("ROI onMouseMove")
          if (mouseDown === true){
            const imageCanvas = MS.$refs['image'];
            imageCanvas.style.width = MS.$refs.canvases_parent_div.style.width;
            imageCanvas.style.height = MS.$refs.canvases_parent_div.style.height;
            current_working_width = MS.$refs['canvases_parent_div'].parentElement.offsetWidth
            current_working_height = current_working_width/MS.aspectRatio
            
            const x = evt.clientX - imageCanvas.getBoundingClientRect().left; // literal pixels on screen\browser
            const y = evt.clientY - imageCanvas.getBoundingClientRect().top; // literal pixels on screen\browser
            // const x = evt.offsetX
            // const y = evt.offsetY
            where_on_image_am_i_x = x*x_scaler/MS.scale + MS.translatePos.x*x_scaler
            where_on_image_am_i_y = y*y_scaler/MS.scale + MS.translatePos.y*y_scaler

            drag.x = where_on_image_am_i_x // forward (mouse slides image around)
            drag.y = where_on_image_am_i_y // forward (mouse slides image around)
            
            // MS.translatePos.x = evt.clientX - startDragOffset.x // reverse (mouse is moving across image)
            // MS.translatePos.y = evt.clientY - startDragOffset.y // reverse (mouse is moving across image)
            console.log(`drag.x: ${drag.x}`)
            console.log(`drag.y: ${drag.y}`)
            MS.roi = JSON.stringify([parseFloat(startDragOffset.x.toFixed(1)),
                                     parseFloat(startDragOffset.y.toFixed(1)),
                                     parseFloat(drag.x.toFixed(1)),
                                     parseFloat(drag.y.toFixed(1))])
            // console.log(MS.roi)
          }
        }

        this.imageCanvasMouseDownROIEventListerner = onMouseDown
        this.imageCanvasMouseUpROIEventListerner = onMouseUp
        this.imageCanvasMouseOutROIEventListerner = onMouseOut
        this.imageCanvasMouseMoveROIEventListerner = onMouseMove
        
        function displayROI(imageCanvas){
          console.log("ROI display")
          let imageCanvasContext = imageCanvas.getContext('2d');
          let roi = JSON.parse(MS.roi);
          x_scaler = MS.imageWidth / parseFloat( MS.$refs.canvases_parent_div.style.width.replace("px","") ) // Adjust x point clicked
          y_scaler = MS.imageHeight / parseFloat( MS.$refs.canvases_parent_div.style.height.replace("px","") ) // Adjust y point clicked
          current_working_width = MS.$refs['canvases_parent_div'].parentElement.offsetWidth
          current_working_height = current_working_width/MS.aspectRatio
          console.log(`MS.scale: ${MS.scale}`)
          console.log(`roi: [${roi[0]}, ${roi[1]}, ${roi[2]}, ${roi[3]}]`)
          console.log(`x_scaler: ${x_scaler} | y_scaler: ${y_scaler}`)
          // top_left = [200, 200]
          // top_right = [1200, 200]
          // bottom_right = [1200, 1200]
          // bottom_left = [200, 1200]
          // [0,1,2,3]
          // [x1,y1,x2,y2]
          // top_left = [(roi[0] - MS.translatePos.x*x_scaler)/x_scaler*MS.scale, (roi[1] - MS.translatePos.y*y_scaler)/y_scaler*MS.scale]
          // top_right = [(roi[2] - MS.translatePos.x*x_scaler)/x_scaler*MS.scale, (roi[1] - MS.translatePos.y*y_scaler)/y_scaler*MS.scale]
          // bottom_right = [(roi[2] - MS.translatePos.x*x_scaler)/x_scaler*MS.scale, (roi[3] - MS.translatePos.y*y_scaler)/y_scaler*MS.scale]
          // bottom_left = [(roi[0] - MS.translatePos.x*x_scaler)/x_scaler*MS.scale, (roi[3] - MS.translatePos.y*y_scaler)/y_scaler*MS.scale]

          // top_left = [(roi[0] * MS.scale - MS.translatePos.x*x_scaler)/x_scaler, (roi[1] * MS.scale - MS.translatePos.y*y_scaler)/y_scaler]
          // top_right = [(roi[2] * MS.scale - MS.translatePos.x*x_scaler)/x_scaler, (roi[1] * MS.scale - MS.translatePos.y*y_scaler)/y_scaler]
          // bottom_right = [(roi[2] * MS.scale - MS.translatePos.x*x_scaler)/x_scaler, (roi[3] * MS.scale - MS.translatePos.y*y_scaler)/y_scaler]
          // bottom_left = [(roi[0] * MS.scale - MS.translatePos.x*x_scaler)/x_scaler, (roi[3] * MS.scale - MS.translatePos.y*y_scaler)/y_scaler]

          // top_left = [roi[0], roi[1]]
          // top_right = [roi[2], roi[1]]
          // bottom_right = [roi[2], roi[3]]
          // bottom_left = [roi[0], roi[3]]
          // top_left = [(roi[0]/x_scaler - MS.translatePos.x/x_scaler)*MS.scale, (roi[1]/y_scaler - MS.translatePos.y)*MS.scale]
          // top_right = [(roi[2]/x_scaler - MS.translatePos.x/x_scaler)*MS.scale, (roi[1]/y_scaler - MS.translatePos.y)*MS.scale]
          // bottom_right = [(roi[2]/x_scaler - MS.translatePos.x/x_scaler)*MS.scale, (roi[3]/y_scaler - MS.translatePos.y)*MS.scale]
          // bottom_left = [(roi[0]/x_scaler - MS.translatePos.x/x_scaler)*MS.scale, (roi[3]/y_scaler - MS.translatePos.y)*MS.scale]

          top_left = [(roi[0] - MS.translatePos.x*x_scaler)*MS.scale, (roi[1] - MS.translatePos.y*y_scaler)*MS.scale]
          top_right = [(roi[2] - MS.translatePos.x*x_scaler)*MS.scale, (roi[1] - MS.translatePos.y*y_scaler)*MS.scale]
          bottom_right = [(roi[2] - MS.translatePos.x*x_scaler)*MS.scale, (roi[3] - MS.translatePos.y*y_scaler)*MS.scale]
          bottom_left = [(roi[0] - MS.translatePos.x*x_scaler)*MS.scale, (roi[3] - MS.translatePos.y*y_scaler)*MS.scale]
          roi_square = [top_left, top_right, bottom_right, bottom_left]
          // Draw roi
          imageCanvasContext.beginPath();
          imageCanvasContext.moveTo(top_left[0], top_left[1]);
          for (let i = 0; i < roi_square.length; i += 1) {
            imageCanvasContext.fillStyle = 'rgba(255, 0, 0, 0.10)';
            imageCanvasContext.strokeStyle = 'rgba(255, 0, 0, 1)'; // Set the line color
            imageCanvasContext.lineWidth = MS.imageWidth / current_working_width; // Set the line width
            imageCanvasContext.moveTo(roi_square[i][0], roi_square[i][1]);
            imageCanvasContext.lineTo(roi_square[i===3 ? 0 : i+1][0], roi_square[i===3 ? 0 : i+1][1]);
            imageCanvasContext.closePath();
            imageCanvasContext.fill();
            imageCanvasContext.stroke();
          }
        }
                
        // Load the annotations for the image
        this.toggleTool("roi")


      },
      async getConfiguration() {
          const response = await fetch('/configuration');
          if (!response.ok) {
              const message = `An error has occured: ${response.status}`;
              throw new Error(message);
          }
          const configuration = await response.json();
          return configuration;
      },
      async getTask(app, user, list_name) {
          await fetch(this.URLS.getTask)
          .then((response) => response.json())
          .then((data) => {
            if (data.rows.length === 1){
              this.task = data.rows[0]
            }else{
              alert("more than one task or less than 1 task...debug...")
            }
          })
      },
      async getImageList() {
        let CA = this; // Classify App Vue Object
        await fetch(this.URLS.getImageList+`?key=${this.list_name}`)
        .then((response) => response.json())
        .then((data) => {
          if (data.rows.length === 1){
            this.images = data.rows[0].value.list
            if (this.images.length === 0){
              this.alert_error = "Image list has no elements."
              setTimeout(()=>{this.alert_error = null}, 2000)
            }
          }else{
            alert("more than one task or less than 1 task...debug...")
          }
        })
      },
      displayCanvasImage(current_image, translatePos={x:0,y:0}, scale=1.0, fromInference=false) {
        return new Promise((resolve, reject) => {
          const image = new Image();
          MS = this;
          image.onload = () => {
            // Once the image is loaded, draw it onto the canvas
            MS.imageWidth = image.width;
            MS.imageHeight = image.height;
            this.roi
            if (MS.roi === '[0,0,0,0]'){
              MS.roi = JSON.stringify([0, 0, MS.imageWidth, MS.imageHeight])
            }
            this.aspectRatio = MS.imageWidth / MS.imageHeight;
            // First time through image load
            current_working_width = this.$refs['canvases_parent_div'].parentElement.offsetWidth
            current_working_height = current_working_width/this.aspectRatio
            this.$refs['canvases_parent_div'].style.width = `${current_working_width}px`
            this.$refs['canvases_parent_div'].style.height = `${current_working_height}px`
            const canvas = this.$refs['image'];
            const context = canvas.getContext('2d');            
            canvas.width = MS.imageWidth
            canvas.height = MS.imageHeight
            max_x_pixels_you_can_shift_image = MS.imageWidth * (1 - (1 / scale)) * ( current_working_width / canvas.width )
            max_y_pixels_you_can_shift_image = MS.imageHeight * (1 - (1 / scale)) * ( current_working_height / canvas.height )
            MS.translatePos.x = Math.max(Math.min(MS.translatePos.x, max_x_pixels_you_can_shift_image), 0)
            MS.translatePos.y = Math.max(Math.min(MS.translatePos.y, max_y_pixels_you_can_shift_image), 0)
            sX = Math.max(Math.min(MS.translatePos.x, max_x_pixels_you_can_shift_image), 0) * (canvas.width / current_working_width)
            sY = Math.max(Math.min(MS.translatePos.y, max_y_pixels_you_can_shift_image), 0) * (canvas.height / current_working_height)
            sW = MS.imageWidth / (scale)
            sH = MS.imageHeight / (scale)
            dX = 0
            dY = 0
            dW = canvas.width
            dH = canvas.height
            context.drawImage(image, sX, sY, sW, sH, dX, dY, dW, dH);
            resolve();
          };
          image.onerror = (error) => {
            reject(error);
          }
          // Set the base64 data as the source of the Image
          image.src = `${this.image.base64}`;
        })
      },
      clearCanvas() {
        this.segmentation_image['base64'] = null
        this.segmentation_image['image_id'] = this.images[current_image]
        // debugger
        //this.displayBrushImage()
        this.displayBrushImage(current_image=this.task.value.current_idx, fromInference=false, translatePos=this.translatePos, scale=this.scale); // fix later
      },
      async displayBrushImage(current_image, translatePos={x:0,y:0}, scale=1.0, fromInference=false, recursion_base_case=0) {
        const segmentation = new Image();
        const roi_image = new Image();
        MS = this;
        this.segmentation_image['image_id'] = this.images[current_image]
        if (this.segmentation_image['base64'] === null){       
          // Create a canvas element with desired dimensions
          image_canvas = this.$refs['image'];
          // adjust parent 
          var segmentation_canvas = document.createElement('canvas');
          segmentation_canvas.width = image_canvas.width; // Set the width of the canvas
          segmentation_canvas.height = image_canvas.height; // Set the height of the canvas
          // Convert the new canvas to a base64 data URL (default format is PNG)
          this.segmentation_image.base64 = segmentation_canvas.toDataURL();
          // Send in image
          segmentation.src = `${this.segmentation_image.base64}`;
        } else {
          segmentation.src = `${this.segmentation_image.base64}`;
        };
        segmentation.onload = () => {
          // Once the image is loaded, draw it onto the canvas
          const segmentationCanvas = this.$refs['segmentation'];
          const segmentationContext = segmentationCanvas.getContext('2d');
          current_working_width = this.$refs['canvases_parent_div'].parentElement.offsetWidth
          current_working_height = current_working_width/this.aspectRatio
          segmentationCanvas.width = MS.imageWidth // clears canvas; Also I think this could be anything as whatever it is, the s square of segmentation will be drawn on it.
          segmentationCanvas.height = MS.imageHeight // clears canvas; Also I think this could be anything as whatever it is, the s square of segmentation will be drawn on it.
          max_x_pixels_you_can_shift_image = MS.imageWidth * (1 - (1 / MS.scale)) * ( current_working_width / segmentationCanvas.width )
          max_y_pixels_you_can_shift_image = MS.imageHeight * (1 - (1 / MS.scale)) * ( current_working_height / segmentationCanvas.height )
          sX = Math.max(Math.min(MS.translatePos.x, max_x_pixels_you_can_shift_image), 0) * (segmentationCanvas.width / current_working_width)
          sY = Math.max(Math.min(MS.translatePos.y, max_y_pixels_you_can_shift_image), 0) * (segmentationCanvas.height / current_working_height)
          sW = MS.imageWidth / (MS.scale)
          sH = MS.imageHeight / (MS.scale)
          dX = 0
          dY = 0
          dW = segmentationCanvas.width
          dH = segmentationCanvas.height
          segmentationContext.drawImage(segmentation, sX, sY, sW, sH, dX, dY, dW, dH);
          // MS.toggleTool("brush")
          // MS.segmentation_z_index = 2
          
          // All of this below is inefficient;
          // This is all to set the tCanvas width and height;
          // What we need is to set this once when the image is loaded. 
          // Why should this ever need to get redrawn?
          // brush() is updating this canvas patch by patch...
          // It is always ready....tech debt!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
          const tCanvas = this.$refs['testcanvas'];
          const tContext = tCanvas.getContext('2d');
          tCanvas.width = MS.imageWidth // clears canvas; this is the issue...by setting this we clear the canvas so we waste time redrawing below because we erased it!
          tCanvas.height = MS.imageHeight // clears canvas; this is the issue...by setting this we clear the canvas so we waste time redrawing below because we erased it!
          sX = 0
          sY = 0
          sW = MS.imageWidth
          sH = MS.imageHeight
          dX = 0
          dY = 0
          dW = tCanvas.width
          dH = tCanvas.height
          tContext.drawImage(segmentation, sX, sY, sW, sH, dX, dY, dW, dH); // redraw because we erased above

          const patchCanvas = this.$refs['patchCanvas'];
          const patchContext = patchCanvas.getContext('2d');
          patchCanvas.width = MS.imageWidth // clears canvas; this is the issue...by setting this we clear the canvas so we waste time redrawing below because we erased it!
          patchCanvas.height = MS.imageHeight // clears canvas; this is the issue...by setting this we clear the canvas so we waste time redrawing below because we erased it!
          sX = Math.max(Math.min(MS.translatePos.x, max_x_pixels_you_can_shift_image), 0) * (segmentationCanvas.width / current_working_width)
          sY = Math.max(Math.min(MS.translatePos.y, max_y_pixels_you_can_shift_image), 0) * (segmentationCanvas.height / current_working_height)
          sW = MS.imageWidth / (scale)
          sH = MS.imageHeight / (scale)
          dX = 0
          dY = 0
          dW = segmentationCanvas.width
          dH = segmentationCanvas.height
          patchContext.drawImage(segmentation, sX, sY, sW, sH, dX, dY, dW, dH); // redraw because we erased above
          
          // Meant to render roi after seg to avoid roi being overwritten by seg variable
          roi_image.src = MS.roi_image['base64']

        }; 
        roi_image.onload = () => {
          current_working_width = this.$refs['canvases_parent_div'].parentElement.offsetWidth
          current_working_height = current_working_width/this.aspectRatio

          const tCanvas = this.$refs['testcanvas'];
          const tContext = tCanvas.getContext('2d');
          const roi = JSON.parse(MS.roi)
          sX = roi[0]
          sY = roi[1]
          sW = roi[2] - roi[0]
          sH = roi[3] - roi[1]
          dX = roi[0]
          dY = roi[1]
          dW = roi[2] - roi[0]
          dH = roi[3] - roi[1]
          tContext.drawImage(roi_image, sX, sY, sW, sH, dX, dY, dW, dH);
          MS.segmentation_image.base64 = tCanvas.toDataURL();

          
          const segmentationCanvas = this.$refs['segmentation'];
          const segmentationContext = segmentationCanvas.getContext('2d');
          // Draw back on segmentation canvas from test canvas
          sX = MS.translatePos.x * (segmentationCanvas.width / current_working_width)
          sY = MS.translatePos.y * (segmentationCanvas.height / current_working_height)
          sW = MS.imageWidth / (MS.scale)
          sH = MS.imageHeight / (MS.scale)
          dX = 0
          dY = 0
          dW = segmentationCanvas.width
          dH = segmentationCanvas.height
          segmentationContext.drawImage(tCanvas, sX, sY, sW, sH, dX, dY, dW, dH);
          // Draw back on patch canvas from test canvas
          var patchCanvas = this.$refs['patchCanvas'];
          var patchContext = patchCanvas.getContext('2d');
          patchContext.drawImage(tCanvas, sX, sY, sW, sH, dX, dY, dW, dH);

          // Delete ROI memory so it doesn't keep redrawing ROI
          MS.roi_image['base64'] = null
        }
        
      },
      changeImageChannel(value) {
        // This function will be called when the selected radio button changes.
        // You can perform any additional actions you need here.
      },
      startBrushing(event) {
        this.isBrushing = true;
        this.brush(event); // Start brushing immediately
      },
      stopBrushing() {
        this.isBrushing = false;
        const segmentationCanvas = this.$refs['segmentation'];
      },
      brush(event) {
        if (this.isBrushing) {
          const segmentationCanvas = this.$refs['segmentation'];
          const segmentationContext = segmentationCanvas.getContext('2d');
          segmentationCanvas.style.width = this.$refs.canvases_parent_div.style.width;
          segmentationCanvas.style.height = this.$refs.canvases_parent_div.style.height;
          const x_scaler = this.imageWidth / parseFloat( this.$refs.canvases_parent_div.style.width.replace("px","") ) // Adjust x point clicked
          const y_scaler = this.imageHeight / parseFloat( this.$refs.canvases_parent_div.style.height.replace("px","") ) // Adjust y point clicked
          const x = event.offsetX;
          const y = event.offsetY;
          // Get the color value based on the selected channel
          let colorValue = 0;
          switch (this.result.radio_button_categories[0].selected) {
            case 'Erase':
              // N: #000000
              colorValue = 0;
              break;
            case 'Background':
              // B: #0000ff
              colorValue = 255;
              break;
            case 'Disc':
              // G: #00ff00
              colorValue = 255 << 8;
              break;
            case 'Cup':
              // R: #ff0000
              colorValue = 255 << 16;
              break;
            case 'Mark GA':
              // R: #ff0000
              colorValue = 255 << 16;
              break;
          }

          // Draw a circle on the segmentationCanvas with the selected color and brush size
          if(this.result.radio_button_categories[0].selected === "Erase"){
            // Set this to "remove" versus add this fillstyle
            segmentationContext.globalCompositeOperation = "destination-out";
            segmentationContext.fillStyle = "rgba(0,0,0,1)";
          } else {
            segmentationContext.globalCompositeOperation = "source-over";
            segmentationContext.fillStyle = `#${colorValue.toString(16).padStart(6, '0')}`;
          }
          segmentationContext.beginPath();
          segmentationContext.arc(x*x_scaler, y*y_scaler, this.brushSize / 2, 0, Math.PI * 2);
          segmentationContext.fill();
          // Get Patch
          //// Borrowed over from displayCanvas as that is essentially what we are doing for the seg mask
          current_working_width = this.$refs['canvases_parent_div'].parentElement.offsetWidth
          current_working_height = current_working_width/this.aspectRatio
          max_x_pixels_you_can_shift_image = this.imageWidth * (1 - (1 / this.scale)) * ( current_working_width / segmentationCanvas.width )
          max_y_pixels_you_can_shift_image = this.imageHeight * (1 - (1 / this.scale)) * ( current_working_height / segmentationCanvas.height )
          // Define the coordinates and dimensions of the patch you want to capture
          const x_patch = Math.max(Math.min(this.translatePos.x, max_x_pixels_you_can_shift_image), 0) * (segmentationCanvas.width / current_working_width); // X-coordinate of the top-left corner of the patch
          const y_patch = Math.max(Math.min(this.translatePos.y, max_y_pixels_you_can_shift_image), 0) * (segmentationCanvas.height / current_working_height); // Y-coordinate of the top-left corner of the patch
          const width_patch = Math.floor(this.imageWidth / (this.scale)); // Width of the patch
          const height_patch = Math.floor(this.imageHeight / (this.scale)); // Height of the patch
          // Create a new canvas element to hold the captured patch
          const patchCanvas = this.$refs.patchCanvas
          // Get a 2D rendering context for the new canvas
          const patchContext = patchCanvas.getContext('2d');
          patchCanvas.width = width_patch
          patchCanvas.height = height_patch
          // Draw the specified region from the source canvas onto the new canvas
          sX = 0
          sY = 0
          sW = segmentationCanvas.width // width_patch
          sH = segmentationCanvas.height // height_patch
          dX = 0
          dY = 0
          dW = patchCanvas.width
          dH = patchCanvas.height
          patchContext.drawImage(segmentationCanvas, sX, sY, sW, sH, dX, dY, dW, dH);

          tcanvas = this.$refs.testcanvas
          tcanvas.style.width = parseFloat( this.$refs.canvases_parent_div.style.width.replace("px","") )// DO WE NEED?
          tcanvas.style.height = parseFloat( this.$refs.canvases_parent_div.style.height.replace("px","") )// DO WE NEED?
          tcontext = tcanvas.getContext('2d');
          sX = 0
          sY = 0
          sW = width_patch
          sH = height_patch
          dX = x_patch
          dY = y_patch
          dW = width_patch
          dH = height_patch

          tcontext.clearRect(dX, dY, dW, dH);
          tcontext.drawImage(patchCanvas, sX, sY, sW, sH, dX, dY, dW, dH);
          this.segmentation_image.base64 = tcanvas.toDataURL();

        }
      },
      getTools(app, tool_set) {
        fetch(this.URLS.getToolSet + `/${app}/${tool_set}`)
        .then((response) => response.json())
        .then((data) => {
          if (data.rows.length === 1){
            // Store tool_set and make results object to match
            var tool_set = data.rows[0].value.tools
            var result = JSON.parse(JSON.stringify(data.rows[0].value.tools));
            this.result = result; 
            this.tool_set = tool_set;
          }else{
            this.alert_error = "Can't find specified tool set"
            setTimeout(()=>{this.alert_error = null}, 2000)
          }
        })
      },
      async getBase64DataOfImageFromCouch(image_id) {
        // old ${this.SSL===true ? 'https' : 'http'}://${this.DNS}:${this.HTTP_PORT}
        const url = `/get_image/${image_id}`;
        try {
          const response = await fetch(url);
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
          const data = await response.text();
          return `data:image/png;base64,${data}`;
        } catch (error) {
          throw error; // Rethrow the error for handling in the calling function
        }
      },
      async performInference() {
        let MSA = this; // Classify App Vue Object
        this.inferenceLoading = true;
        this.inferenceDoneTraining = false;
        await this.uploadImage();
        // debugger
        image_name = this.segmentation_image.image_id.split('.')[0] // sans extension, as shows up in datastore_v2.json
        const url = this.URLS.performInference+'?image=' + image_name + '&output=image';
        const headers = {
          'Accept': 'application/json',
        };
        // Create a new FormData object to handle multipart/form-data
        const formData = new FormData();
        // Add the parameters, empty file field, and label (if needed) to the FormData
        // formData.append('params', JSON.stringify({"roi": JSON.parse(this.roi)}));
        // USER KEY FOR GA STUDY
        user_key = {
          'bbearce': true,

          'andres': false,
          'larguinchona': false,
          'bmarks': false,
          'bhogan': false,
          'iroseto': false,
          'lbarrientos': false,
          'dmilner': false,
          'rgnanaraj': false,
          'zgill': false,
          'mtukel': false,
        }
        user_key[this.user]
        formData.append('params', JSON.stringify({"roi": JSON.parse(this.roi), "trained":user_key[this.user] ? user_key[this.user] : false}));
        formData.append('file', '');
        formData.append('label', '');
        // Send a POST request with the FormData using the fetch API
        fetch(url, {
          method: 'POST',
          headers: headers,
          body: formData,
        })
        .then(response => response.blob())
        .then(imageBlob => {
          const reader = new FileReader(); // While FileReader used for files, the api works for imageBlob data.
          reader.onloadend = async function() {
            // The result contains the Base64 string
            const base64String = reader.result;
            MSA.inferenceLoading = false;
            MSA.inferenceDoneTraining = true;
            // DRAW PATCH FROM INFERENCE ROI
            MSA.roi_image['base64'] = base64String
            // MSA.segmentation_image['base64'] = base64String // If this works this is obsolete
            await MSA.displayBrushImage(current_image=MSA.task.value.current_idx, fromInference=true, translatePos=MSA.translatePos, scale=MSA.scale); // fix later
            MSA.toggleTool("brush")
            // debugger
            MSA.$refs.timer.start(init=true)
          };
          reader.readAsDataURL(imageBlob);
        })
        .catch(error => {
          this.inferenceLoading = false;
          this.inferenceDoneTraining = false;
        });
      },
      async uploadImage() {
        // Define the URL and headers
        
        image_name = this.image.image_id.split('.')[0];
        url = this.URLS.uploadImage + `?image=${image_name}`;
        headers = {
            'Accept': 'application/json',
        };
        // Create a new FormData object to handle multipart/form-data
        formData = new FormData();
        formData.append('params', JSON.stringify({}));
        // Add the image data as a blob with a "image/png" type
        formFileName = `${image_name}.png`;
        byteCharacters = atob(this.image.base64.split(',')[1]);
        byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        byteArray = new Uint8Array(byteNumbers);
        imageBlob = new Blob([byteArray], { type: 'image/png' });
        formData.append('file', imageBlob, formFileName);
        
        try {
            // Send a PUT request with the FormData using the fetch API
            response = await fetch(url, {
                method: 'PUT',
                headers: headers,
                body: formData,
            });
            const file = await response.json();
            // Handle the response here if needed
            
        } catch (error) {
        }
      },
      async saveLabel() {
        this.saveLoading = true;
        this.saveDoneTraining = false;
        await this.uploadImage();
        this.alert_info = "Saved Image"
        this.saveLoading = false;
        this.saveDoneTraining = true;
        setTimeout(()=>{this.alert_info = null}, 2000)
        // Define the URL and headers
        image_name = this.segmentation_image.image_id.split('.')[0] // sans extension, as shows up in datastore_v2.json
        // image_name = "AAA"
        const url = this.URLS.saveLabel+`?image=${image_name}&tag=final`;
        const headers = {
            'Accept': 'application/json',
        };
        // Create a new FormData object to handle multipart/form-data
        const formData = new FormData();
        formData.append('params', JSON.stringify({}));
        // Add the image data as a blob with a "image/png" type
        const formFileName = `${image_name}.png`;
        const byteCharacters = atob(this.segmentation_image.base64.split(',')[1]);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        const imageBlob = new Blob([byteArray], { type: 'image/png' });
        formData.append('label', imageBlob, formFileName);
        // Send a PUT request with the FormData using the fetch API
        fetch(url, {
            method: 'PUT',
            headers: headers,
            body: formData,
        })
        .then(response => response.json())
        .then(file => {
            // setResponseData(file);
        })
        .catch(error => {
        });
      },
      trainOnLabels() {
        this.trainLoading = true; // Set loading to true
        this.trainDoneTraining = false;
        // Define the URL and headers
        const url = this.URLS.trainOnLabels + '?run_sync=false&enqueue=false';
        const headers = {
          'Accept': 'application/json',
          'Content-Type': 'application/json',
        };
        // Define the POST request body data
        const postData = {};
        // Send a POST request using the fetch API
        fetch(url, {
          method: 'POST',
          headers: headers,
          body: JSON.stringify(postData),
        })
        .then(response => response.json())
        .then(data => {
          // Start polling for job status using setInterval
          this.trainIntervalId = setInterval(this.checkJobStatus, 1000); // Adjust the interval as needed
        })
        .catch(error => {
        });
      },
      checkJobStatus() {
        // Make an API request to check the job status
        // You should implement the logic to check the status and update the loading spinner accordingly
        // For example, you can make a GET request to an endpoint that provides the job status
        MSA = this;
        fetch(this.URLS.trainStatus, {
            method: 'GET',
            headers: {
                'Accept': 'application/json',
            },
            })
            .then(response => response.json())
            .then(data => {
            if (data.status === 'DONE') {
                MSA.trainLoading = false;
                MSA.trainDoneTraining = true;
            }
            })
            .catch(error => {
            });
        // When the job is completed or has a certain status, you can stop the interval
        if (this.jobCompleted) {
          clearInterval(this.intervalId);
          this.trainLoading = false; // Set loading to false when the job is completed
        }
      },
      hideCanvas() {
        if(this.segmentation_image.display === ""){
          // this.hideBrushButtonText = "Unhide Brush Canvas" // In case we want it 
          this.segmentation_image.display = "none"
        }else{
          // this.hideBrushButtonText = "Hide Brush Canvas" // In case we want it 
          this.segmentation_image.display = ""
        }
      },
      hidePolygon() {
        if(this.polygonDisplay === ""){
          // this.hidePolygonButtonText = "Unhide Polygon" // In case we want it 
          this.polygonDisplay = "none"
        }else{
          // this.hidePolygonButtonText = "Hide Polygon" // In case we want it 
          this.polygonDisplay = ""
        }
      },
      toggleTool(variable) {
        // if we clicked the Select Polygon Tool button
        if(variable === "image" || variable === "roi"){
          this.image_selected = true
          this.segmentation_selected = false
          this.polygon_selected = false
          this.image_opacity = 0.9
          this.image_z_index = 2
          this.polygons_z_index = 1
          this.segmentation_z_index = 0
          const imageCanvas = MS.$refs['image'];
          if (variable === "image"){
            imageCanvas.addEventListener('mousedown', this.imageCanvasMouseDownInitCanvasEventListerner)
            imageCanvas.addEventListener('mouseup', this.imageCanvasMouseUpInitCanvasEventListerner)
            imageCanvas.addEventListener('mouseover', this.imageCanvasMouseOverInitCanvasEventListerner)
            imageCanvas.addEventListener('mouseout', this.imageCanvasMouseOutInitCanvasEventListerner)
            imageCanvas.addEventListener('mousemove', this.imageCanvasMouseMoveInitCanvasEventListerner)
            imageCanvas.removeEventListener('mousedown', this.imageCanvasMouseDownROIEventListerner)
            imageCanvas.removeEventListener('mouseup', this.imageCanvasMouseUpROIEventListerner)
            imageCanvas.removeEventListener('mouseout', this.imageCanvasMouseOutROIEventListerner)
            imageCanvas.removeEventListener('mousemove', this.imageCanvasMouseMoveROIEventListerner)
          } else if (variable === "roi"){
            imageCanvas.addEventListener('mousedown', this.imageCanvasMouseDownROIEventListerner)
            imageCanvas.addEventListener('mouseup', this.imageCanvasMouseUpROIEventListerner)
            imageCanvas.addEventListener('mouseout', this.imageCanvasMouseOutROIEventListerner)
            imageCanvas.addEventListener('mousemove', this.imageCanvasMouseMoveROIEventListerner)
            imageCanvas.removeEventListener('mousedown', this.imageCanvasMouseDownInitCanvasEventListerner)
            imageCanvas.removeEventListener('mouseup', this.imageCanvasMouseUpInitCanvasEventListerner)
            imageCanvas.removeEventListener('mouseover', this.imageCanvasMouseOverInitCanvasEventListerner)
            imageCanvas.removeEventListener('mouseout', this.imageCanvasMouseOutInitCanvasEventListerner)
            imageCanvas.removeEventListener('mousemove', this.imageCanvasMouseMoveInitCanvasEventListerner)
          }else {
            alert("Something unexpected is happeing - line 1707 ish...")
          }
        } else if (variable === "polygon"){
          this.polygon_selected = true
          this.image_selected = false
          this.segmentation_selected = false
          this.image_opacity = 1
          this.polygons_z_index = 2
          this.segmentation_z_index = 1
          this.image_z_index = 0
          this.polygonDisplay = ""
          this.BrushButtonText = 'Brush'
          this.PolygonButtonText = 'Shape (Selected)'
        } else if (variable === "brush"){
          this.segmentation_selected = true
          this.polygon_selected = false
          this.image_selected = false
          this.image_opacity = 0.9
          this.segmentation_z_index = 2
          this.polygons_z_index = 1
          this.image_z_index = 0
          this.result.radio_button_categories[0]['selected'] = "Mark GA"
          this.segmentation_image.display = ""
          this.BrushButtonText = 'Brush (Selected)'
          this.PolygonButtonText = 'Shape'
        } else {
          this.segmentation_selected = true
          this.polygon_selected = false
          this.image_selected = false
          this.image_opacity = 0.9
          // if we clicked a radio button
          this.segmentation_z_index = 2
          this.polygons_z_index = 1
          this.image_z_index = 0
          this.result.radio_button_categories[0]['selected'] = variable
          this.segmentation_image.display = ""
          this.BrushButtonText = 'Brush (Selected)'
          this.PolygonButtonText = 'Shape'
        }

      },
      // For the submit form
      submit() {
        //this.$v.$touch() // for use with veulidate which you haven't setup for this app
        // this.$refs.form.$el.submit() // Normal submit but we want to send results in a better organized way
        // Define the URL and headers
        let error = null;
        this.result['radio_button_categories'].forEach((v, i, a) => {
          if (v['selected'] === null && v['category_id'] != 'Choose Region To Segment'){
            error = true
            this.alert_error = "You must make a selection for the radio buttons not related to segmentation."
            setTimeout(()=>{this.alert_error = null}, 2000)
          }
        })
        segmentation_name = this.segmentation_image.image_id.split('.')[0] // sans extension, as shows up in datastore_v2.json
        const headers = {
            'Accept': 'application/json',
        };
        if (!error){
          // debugger
          // Create a new FormData object to handle multipart/form-data
          const formData = new FormData();
          // Add the image data as a blob with a "image/png" type
          const formFileName = `${segmentation_name}.png`;
          // Save segmentation canvas to segmentation_image.base64
          // var segmentationCanvas = this.$refs['segmentation'];
          var segmentationCanvas = this.$refs['testcanvas'];
          this.segmentation_image.base64 = segmentationCanvas.toDataURL('image/png')
          //
          const byteCharacters = atob(this.segmentation_image.base64.split(',')[1]);
          const byteNumbers = new Array(byteCharacters.length);
          for (let i = 0; i < byteCharacters.length; i++) {
              byteNumbers[i] = byteCharacters.charCodeAt(i);
          }
          const byteArray = new Uint8Array(byteNumbers);
          const imageBlob = new Blob([byteArray], { type: 'image/png' });
          formData.append('image', imageBlob, formFileName);
          // Add metadata
          var d = new Date()
          this.result['_id'] = `${this.task.id}-result-${this.image.image_id}`
          this.result['user'] = this.user
          this.result['date'] = d.toTimeString()
          this.result['list_name'] = this.task.value.list_name
          this.result['app'] = "monaiSegmentation"
          this.result['type'] = "result"
          this.result['coco_annotation'] = this.coco_annotations
          this.result['taskid'] = this.task.id
          this.result['total_sec'] = this.total_sec
          this.result['timer'] = `${this.min.toString().padStart(2, '0')}:${this.sec.toString().padStart(2, '0')}`
          formData.append('json', JSON.stringify(this.result));
          fetch(this.URLS.taskResult, {
            method: 'POST',
            // headers: {
            //     'Content-Type': 'application/json'
            // },
            body: formData
          })
          .then((response) => response.json())
          .then((data) => {
            window.location.replace(this.URLS.monaiSegmentationApp);
          })
        }
      },
      // This might be a relect of a copy and paste...don't think this is used
      clear() {
        this.$v.$reset()
        this.user = ''
        this.imageListName = ''
        this.imageListTypeSelect = ''
        this.taskOrder = ''
      },
      beforeDestroy() {
        if (this.resizeObserver) {
          this.resizeObserver.disconnect(); // Clean up the observer when the component is destroyed
        }
      },
      resetToPreviousResult() {
        if(this.task['value']['current_idx'] === 0){
          this.alert_error = "You're on the first image of list!"
          setTimeout(()=>{this.alert_error = null}, 2000)
          return
        }
        Task = {
          id: this.task['id'],
          key: this.task['key'],
          value: this.task['value'],
          last_result_key: this.task.id+"-"+"result"+"-"+this.images[this.task.value.current_idx-1]
        }
        const headers = {
          'Content-Type': 'application/json',
        };
        fetch(this.URLS.resetToPreviousResult+"/"+`${this.app}`, {
          method: 'POST',
          headers: headers,
          body: JSON.stringify(Task)
        })
        .then((response) => response.json())
        .then((data) => {
          if (data["deleted_result_id"] === null){
              this.alert_error = "Can't find deleted_result_id"
              setTimeout(()=>{this.alert_error = null}, 2000)
          }else{
            this.alert_info = `Deleted ${data["deleted_result_id"]}`
            setTimeout(()=>{this.alert_info = null; location.reload();}, 2000)
          }
        })
      },
    },


  })
</script>


{% endblock %}
